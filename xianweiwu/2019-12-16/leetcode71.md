## 简化路径

> 以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。<br/>  
> 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；
> 此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；
> 两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 <br/>
> 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。<br/>
> 最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。

示例1:
```text
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

示例2:
```text
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

示例3:
```text
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

示例4:
```text
输入："/a/./b/../../c/"
输出："/c"
```

示例5:
```text
输入："/a/../../b/../c//.//"
输出："/c"
```

示例6:
```text
输入："/a//b////c/d//././/.."
输出："/a/b/c"
```

- 解法
  - 解题思路: 
    1. 通过观察得知路径为`.`,`/`相当于没有改变路径，可以忽略
    2. 使用数组`arr`储存路径。这样子路径中就只有`..`或者真实的下一个路径
    3. 处理数组`arr`：如果遇到`..`，则退回上一个存储的位置，否则保持到新数组`result`中
    4. 将数组`result`转成字符串返回
    
  - 代码
    ```javascript
    /**
     * @param {string} path
     * @return {string}
     */
    const simplifyPath = function(path) {
      const arr = path.split('/').filter(item => !['.', '/',''].includes(item));
      const result = [];
      arr.forEach(item => {
        if(item === '..'){
          result.pop();
        }else{
          result.push(item);
        }
      });
      return '/' + result.join('/');
    };
    ```
    
  - 测试结果
  ![](result71-1.jpg)
  
  - 算法分析
    - 时间复杂度: `O(n)`
    - 空间复杂度: `O(n)`